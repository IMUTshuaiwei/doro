"""
[#ExecutionOrder = 1]

This script generates type hints for the configuration files in the project.
It reads JSON files from the 'resources/config' directory and generates
Python TypedDict classes with appropriate type hints.
The generated type hints are saved in the 'src/auto_typehint' directory.
"""

import json
from typing import Any, Dict, Final, List, Union

TYPING_HEAD: Final[
    str
] = """\
from __future__ import annotations
from typing import Literal, TypedDict
"""

PACKAGE_HEAD: Final[
    str
] = """\
from . import ConfigHint
from . import FileIndexHint
from . import ThemeHint

__all__ = [
    'ConfigHint',
    'FileIndexHint',
    'ThemeHint',
]
"""

class_name_list: List[str] = []
literal_name_list: List[str] = []
new_class_list: List[str] = []
class_literals: List[str] = []
class_value_literals: List[str] = []


def format_name(name: str) -> str:
    return name


def generate_typeddict(
    class_name: str,
    class_dict: Dict[str, Union[Dict[str, Any], Any]],
    *,
    __init: bool = True,
) -> str:
    global new_class_list, class_literals, class_name_list, literal_name_list, class_value_literals
    if __init:
        class_name_list.clear()
        literal_name_list.clear()
        new_class_list.clear()
        class_literals.clear()
        class_value_literals.clear()
    formatted_class_name = format_name(class_name)
    typeddict: str = f"class {formatted_class_name}Param(TypedDict):\n"
    class_name_list.append(f"{formatted_class_name}Param")
    class_literals.append(
        f"{formatted_class_name}Literal = Literal[{', '.join([f'\"{k}\"' for k in class_dict.keys()])}]"
    )
    literal_name_list.append(f"{formatted_class_name}Literal")
    child_class_names: List[str] = []
    for key, value in class_dict.items():
        if isinstance(value, dict):
            formatted_child_param = format_name(key)
            typeddict += f"    {formatted_child_param}: {formatted_child_param}Param\n"
            child_class_names.append(f"{formatted_child_param}Param")
            generate_typeddict(class_name=key, class_dict=value, __init=False)  # type: ignore
        elif isinstance(value, str):
            typeddict += f"    {key}: str\n"
        else:
            typeddict += f"    {key}: {type(value).__name__}\n"

    if child_class_names:
        class_literals.append(
            f"{formatted_class_name}ParamLiteral = Literal[{', '.join(child_class_names)}]"
        )

    new_class_list.append(typeddict)

    total_typeddict: str = "\n\n".join(new_class_list)
    total_literal: str = (
        "\n".join(class_literals) + "\n\n" + "\n".join(class_value_literals)
    )

    return total_typeddict + "\n\n" + total_literal + "\n"


def load_config() -> Dict[str, Any]:
    with open("resources/config/default_config.json", "r", encoding="utf-8") as f:
        config_json = json.load(f)
        return config_json


def load_file_index() -> Dict[str, Any]:
    with open("resources/config/file_index.json", "r", encoding="utf-8") as f:
        file_index_json = json.load(f)
        return file_index_json


def load_theme() -> Dict[str, Any]:
    with open("resources/config/theme.json", "r", encoding="utf-8") as f:
        theme_json = json.load(f)
        return theme_json


def write_to(file_path: str, head: str, data: str) -> None:
    data = (
        "# This file is auto-generated by build/generate_typehints.py\n" + head + data
    )

    with open(file_path, "w", encoding="utf-8") as f:
        f.write(data)


def generate() -> None:
    cfg_output = generate_typeddict("Config", load_config())
    file_index_output = generate_typeddict("FileIndex", load_file_index())
    theme_output = generate_typeddict("Theme", load_theme())

    write_to(
        "src/auto_typehint/ConfigHint.py",
        TYPING_HEAD,
        cfg_output,
    )
    write_to(
        "src/auto_typehint/FileIndexHint.py",
        TYPING_HEAD,
        file_index_output,
    )
    write_to(
        "src/auto_typehint/ThemeHint.py",
        TYPING_HEAD,
        theme_output,
    )
    write_to("src/auto_typehint/__init__.py", PACKAGE_HEAD, "")


if __name__ == "__main__":
    generate()
